(ns loco.core
  (:require [loco.model :as model])
  (:import (org.chocosolver.solver.variables IntVar)
           (org.chocosolver.solver.exception SolverException)
           org.chocosolver.solver.variables.Variable
           (org.chocosolver.solver
            Model
            ParallelPortfolio
            ResolutionPolicy
            Solution
            Solver)

           org.chocosolver.solver.constraints.Constraint
           (org.chocosolver.solver.search.loop.monitors ISearchMonitorFactory)
           (org.chocosolver.util ESat)))

(defn- namey?
  [x]
  (try (boolean (name x))
    (catch Exception e
      false)))

(defn- id
  []
  (gensym "id"))

(def ^:dynamic *solver*
  "(internal) Bound to the Loco solver object during problem
  construction / solving"
  nil)


(defrecord LocoSolver
  [csolver memo-table my-vars n-solutions])

(defn- new-solver
  []
  (->LocoSolver
    ;;(Solver. (str (gensym "solver")))
   (Model.)
   (atom {})
   (atom {})
   (atom 0)))

(defn- get-val
  [v]
  (.getLB v))

;;FIXME: this can be done at the compile phase, instead of the creation phase..
(defn- find-int-var
  [n]
  (let [model (:csolver *solver*)]
    (or (@(:my-vars *solver*) n)
        (throw (IllegalAccessException. (str "var with name " n
                                             " doesn't have a corresponding "
                                             "\"$in\" call in the top-level"
                                             " of the problem"))))))

(defmulti ->choco*
  "(INTERNAL) Given Clojure data generated by the Loco DSL, returns a
  Choco variable (to be used inside a constraint), or returns a
  constraint (to be posted to the solver)."
  (fn [data]
    (if (and (vector? data)
             (keyword? (first data)))
      :vector-var-name
      (or (:type data) (type data)))))

(defmethod ->choco* java.lang.Number [data]
  data)

(defmethod ->choco* clojure.lang.Keyword [data]
  (find-int-var data))

(defmethod ->choco* :vector-var-name [data]
  (find-int-var data))

(defn ->choco
  "(INTERNAL) Memoized version of ->choco*"
  [data]
  (let [lookup (when (:id data)
                 (@(:memo-table *solver*) (:id data)))]
    (if lookup
      lookup
      (let [result (->choco* data)]
        (when (:id data)
          (swap! (:memo-table *solver*) assoc (:id data) result))
        result))))

(defn- constrain!
  [constraint]
  (let [model (:csolver *solver*)]
    ;; constraints can post themselves
    ;; from tutorials
    ;; model.allDifferent(vars).post();
    (.post constraint)))

(defn problem->solver
  "creates a model from declarations from constraints namespace. e.g. ($in...)"
  [problem]
  (let [problem (model/compile problem)
        s (new-solver)]
    (binding [*solver* s]
      (doseq [i-beta problem
              :let [i (->choco i-beta)]
         ;;     :let [i (->choco* i-beta)]
              ]
        ;; (println 'i-beta i-beta)
        ;; (println 'i i)
        ;; (println '(instance? Constraint i) (instance? Constraint i))
        ;; (println "")
        (when (instance? Constraint i)
          ;; (println '(constrain! i))
          (constrain! i)))
      ;; FIXME: things changed in 4.0.0
      ;; http://www.choco-solver.org/apidocs/index.html
      ;; org.chocosolver.solver.search.strategy.Search
      ;; minDomLBSearch
      #_(let [vars (vals @(:my-vars s))
            strategy (ISF/minDom_LB (into-array IntVar vars))]
        (.set (:csolver s) (into-array AbstractStrategy [strategy])))
      s
      )))

(defn- feasible?
  "After the problem has executed, determines whether the problem was feasible"
  []
  (let [f (.isFeasible (:csolver *solver*))]
    (condp = f
      ESat/TRUE true
      ESat/FALSE false
      ESat/UNDEFINED (throw (Exception. "Solver has not been run yet")))))

(defn new-solution! [^Model model]
  ;; (Solution. (Model. ) (make-array Variable 0))
  ;; (into-array [1]) with variables when we have them
  (Solution. model (make-array Variable 0)))

(defn- solve!
  [args]
  (let [n-atom (:n-solutions *solver*)
        ^Model model (:csolver *solver*)
        csolver (.getSolver model)
        ;;FIXME: varsToStore part of (Solution.) is the return values
        ;;of ($in...) need to save them.
        solution (new-solution! model)]
    (when (:timeout args)
      (.limitTime csolver (long (:timeout args))))
    (cond
      (:maximize args) (do (.findOptimalSolution csolver ResolutionPolicy/MAXIMIZE
                                                 (->choco (:maximize args)))
                           (and (feasible?)
                                (swap! n-atom inc)
                                true))
      (:minimize args) (do (.findOptimalSolution csolver ResolutionPolicy/MINIMIZE
                                                 (->choco (:minimize args)))
                           (and (feasible?)
                                (swap! n-atom inc)
                                true))
      :else (if (= @n-atom 0)
              (and (.solve csolver)
                   (.record solution)
                   (swap! n-atom inc)
                   true)
              (and (.solve csolver)
                   (.record solution)
                   (swap! n-atom inc)
                   true)))))

(defn- return-next-solution []
  (let [
        vars @(:my-vars *solver*)
        starts-with-underscore (fn [var-name]
                                 (if (keyword? var-name)
                                   (= (first (name var-name)) \_)
                                   (= (first (name (first var-name))) \_)))
        ]

    (->> vars
         (remove (fn [[var-name _]]
                   (starts-with-underscore var-name)))
         (map (fn [[var-name v]]
                [var-name (get-val v)]))
         (into {}))))

(defn- solution*
  [args]
  (when (solve! args)
    (return-next-solution)))

(defn solution
  "Solves the problem using the specified constraints and returns a map from variable names to their values (or nil if there is no solution).
Keyword arguments:
- :maximize <var> - finds the solution maximizing the given variable.
- :minimize <var> - finds the solution minimizing the given variable.
- :feasible true - optimizes time by guaranteeing that the problem is feasible before trying to maximize/minimize a variable.
- :timeout <number> - stops after a certain amount of milliseconds (returns nil, or best solution so far when min/maxing a variable)
Note: returned solution maps have the metadata {:loco/solution <n>} denoting that it is the nth solution found (starting with 0)."
  [problem & args]
  (binding [*solver* (problem->solver problem)]
    (let [args (apply hash-map args)]
      (solution* args))))

(defn- Solution->solution-map [S]
  (into {} (for [[var-name v] @(:my-vars *solver*)
                 :when (if (keyword? var-name)
                         (not= (first (name var-name)) \_)
                         (not= (first (name (first var-name))) \_))]
             [var-name (.getIntVal S v)])))

(defn solutions
  "Solves the solver using the constraints and returns a lazy seq of maps (for each solution) from variable names to their values.
Keyword arguments:
- :timeout <number> - the sequence ends prematurely if the timer exceeds a certain number of milliseconds.
- :maximize <var> - finds all solutions that maximize the given var or expression. NOT lazy.
- :minimize <var> - finds all solutions that minimize the given var or expression. NOT lazy."
  [problem & args]
  (let [solver (problem->solver problem)
        model (:csolver solver)
        ^Solver csolver (.getSolver model)
        args (apply hash-map args)
        timeout (:timeout args)
        maximize (:maximize args)
        minimize (:minimize args)
        args (dissoc args :timeout :maximize :minimize)]
    (when timeout
      (.limitTime csolver timeout))
    (cond
      maximize (binding [*solver* solver]
                 (do (.findAllOptimalSolutions csolver ResolutionPolicy/MAXIMIZE
                                               (->choco maximize)
                                               false)
                     (map #(binding [*solver* solver]
                             (Solution->solution-map %))
                          (.. csolver (getSolutionRecorder) (getSolutions)))))
      minimize (binding [*solver* solver]
                 (do (.findAllOptimalSolutions csolver ResolutionPolicy/MINIMIZE
                                               (->choco minimize)
                                               false)
                     (map #(binding [*solver* solver]
                             (Solution->solution-map %))
                          (.. csolver (getSolutionRecorder) (getSolutions)))))
      :else (take-while identity
                        (repeatedly #(binding [*solver* solver]
                                       (solution* args)))))))
